---
name: tauri-best-practices-writing-plugin-permissions
description: Writing plugin permissions — autogenerated allow/deny, permission files, default set, scope schema. Use when defining permissions for a Tauri plugin.
---

# Writing Plugin Permissions

When authoring a Tauri **plugin**, you define **permissions** so app developers can grant access per window via **capabilities**. Use autogenerated permissions for simple command allow/deny; add custom permission files and **scope** schema when you need path/URL or other constraints.

## Autogenerated permissions

In the plugin’s **build.rs**, list commands (snake_case) in **tauri_plugin::Builder::new(COMMANDS)**. Tauri generates **allow-&lt;command&gt;** and **deny-&lt;command&gt;** permissions for each. No hand-written permission file is required for basic allow/deny.

```rust
// build.rs
const COMMANDS: &[&str] = &["write_custom_file", "ping"];
fn main() {
    tauri_plugin::Builder::new(COMMANDS).build();
}
```

App developers then reference **plugin-name:allow-write-custom-file** (or **plugin-name:deny-write-custom-file**) in their capability files.

## Custom permission files

- Add **permissions/** in the plugin crate with **.toml** (or .json) files. Each file can define **[[permission]]** (identifier, description, **commands.allow** / **commands.deny**, optional **scope.allow** / **scope.deny**) and **[[set]]** (group of permissions).
- Use **scope** when a command should be restricted by path, URL, or custom data. Define a scope type (e.g. **Entry { path: String }**), implement **schemars::JsonSchema**, and in **build.rs** call **global_scope_schema(schemars::schema_for!(Entry))** (and optionally command-scope schema). Plugin consumers then set **permission.scope.allow** / **deny** in their capability; in the command you read **CommandScope&lt;Entry&gt;** or **GlobalScope&lt;Entry&gt;** and enforce.
- **Default** permission set: add a **default** set (e.g. **permissions/default.toml** with **identifier = "default"**) so apps can use **plugin-name:default** when adding the plugin. Include the permissions you want enabled by default.

## Command implementation

- For **scoped** commands, inject **CommandScope&lt;T&gt;** or **GlobalScope&lt;T&gt;** and call **allows()** / **denies()** to validate the request (e.g. path or URL) before proceeding. Deny overrides allow; implement logic so that scope bypass is impossible.
- See [Permissions](/security/permissions/) and [Scope](/security/scope/) for the permission/scope model; see [Plugin Development](/develop/plugins/) for lifecycle and invoke_handler.

## Key Points

- **Autogenerate** allow/deny per command when you don’t need scopes. **Custom** permission files and **scope schema** when you need path/URL or other constraints.
- Document the permission identifiers and scope shape in your plugin’s README so app developers know what to put in capabilities.

<!--
Source references:
- https://v2.tauri.app/learn/security/writing-plugin-permissions/
- https://v2.tauri.app/develop/plugins/
- https://v2.tauri.app/security/permissions/
- https://github.com/tauri-apps/tauri-docs
-->
